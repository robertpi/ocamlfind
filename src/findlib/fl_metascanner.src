(* $Id: fl_metascanner.src,v 1.3 2002/09/22 20:12:32 gerd Exp $
 * ----------------------------------------------------------------------
 *
 *)

open Fl_metatoken;;


let scan ch =
  (* transform an in_channel to a token stream; 'Space' tokens are left
   * out.
   *)
  let buf = Lexing.from_channel ch in
  let rec next line pos0 =
    let t = Fl_meta.token buf in
    match t with
      Space   -> next line pos0
    | Newline -> next (line+1) (Lexing.lexeme_end buf)
    | Eof     -> let pos = Lexing.lexeme_start buf - pos0 in
                 [< '(line, pos, Eof) >]
    | _       -> let pos = Lexing.lexeme_start buf - pos0 in
                 [< '(line, pos, t); next line pos0 >]
  in
  next 1 0
;;


let parse ch =
  (* Returns list
   * ( name_of_param, ( [ arguments... ], value ) )
   * or raises Stream.Error
   *)

  let rec mk_set l =
    match l with
      x :: l' ->
	if List.mem x l' then mk_set l' else x :: (mk_set l')
    | [] ->
	[]
  in

  let rec parse_all stream =
    match stream with parser
      [< '(line, col, Name n);
         props = parse_properties
	  ?? ("Error in 'name = value' clause  in line " ^
		   string_of_int line ^ " position " ^ string_of_int col);
	 rest = parse_all
	  ?? ("Error in 'name = value' clause  in line " ^
	     string_of_int line ^ " position " ^ string_of_int col)
       >]
	-> let args, value = props in
	(n, (Sort.list ( <= ) (mk_set args), value)) :: rest
    | [< '(_,_,Eof) >]
	-> []
    | [< '(line,col,_) >]
	-> raise(Stream.Error("Expected 'name = value' clause  in line " ^
			      string_of_int line ^ " position " ^
			      string_of_int col))

  and parse_properties stream =
    match stream with parser
      [< '(line,col,LParen);
	 '(line1,col1,Name n)
	  ?? ("After a '(' there must be an argument name in line " ^
	    string_of_int line ^ " position " ^ string_of_int col);
	 args = parse_arguments;
	 '(line2,col2,Equal)
	  ?? ("'=' expected after '(arguments)' clause in line " ^
	    string_of_int line ^ " position " ^ string_of_int col);
         '(line3,col3,String s)
	 ?? ("Expected string constant after '=' in line " ^
	    string_of_int line2 ^ " position " ^ string_of_int col2)
      >]
	-> n::args, s
    | [< '(line,col,Equal); '(_,_,String s)
	 ?? ("'=' must be followed by a string constant in line " ^
	    string_of_int line ^ " position " ^ string_of_int col)
      >]
	-> [], s
    | [< '(line,col,_) >]
	-> raise(Stream.Error("Expected a '=' or a '(arguments,...)=' clause in line " ^
			      string_of_int line ^ " position " ^
			      string_of_int col))

  and parse_arguments stream =
    match stream with parser
      [< '(line,col,Comma);
	 '(line1,col1,Name n)
	 ?? ("Expected argument name after ',' in line " ^
	    string_of_int line ^ " position " ^ string_of_int col);
	 args = parse_arguments
      >]
	-> n :: args
    | [< '(_,_,RParen) >]
	-> []
    | [< '(line,col,_) >]
	-> raise(Stream.Error("Another argument or a ')' expected in line " ^
			      string_of_int line ^ " position " ^
			      string_of_int col))

  in

  let rec check l =
    match l with
      [] -> ()
    | (n, (args, value)) :: l' ->
	List.iter
	  (fun (n', (args', value')) ->
	    if n=n' & args=args' then
	      raise(Stream.Error ("Double definition of '" ^ n ^ "'" ^
				  (if args = [] then "" else
				  "(" ^  String.concat "," args ^ ")"))))
	  l';
	check l'
  in

  let l = parse_all (scan ch) in
  check l;
  l
;;


let lookup name predicate_list parsed_file =
  let rec search best_n best_value l =
    match l with
      [] ->
	if best_n >= 0 then
	  best_value
	else
	  raise Not_found
    | (name', (predicates, value)) :: l' ->
	if name = name' &
	   (List.for_all (fun p -> List.mem p predicate_list) predicates) &
	   (List.length predicates > best_n) then
	  search (List.length predicates) value l'
	else
	  search best_n best_value l'
  in
  search (-1) "" parsed_file
;;


(* ======================================================================
 * History:
 *
 * $Log: fl_metascanner.src,v $
 * Revision 1.3  2002/09/22 20:12:32  gerd
 * 	Renamed modules (prefix fl_)
 *
 * Revision 1.2  2002/09/22 13:47:50  gerd
 * 	Changed again '?' to '??' (since O'Caml 3.04)
 *
 * Revision 1.1  2002/09/22 13:32:30  gerd
 * 	Renamed file from metascanner.src to fl_metascanner.src to avoid
 * name clashes
 *
 * ======================================================================
 * OLD LOGS FOR metascanner.src:
 *
 * Revision 1.4  2001/10/12 15:02:57  gerd
 * 	Reverted from '??' syntax to '?' syntax for stream parsers.
 *
 * Revision 1.3  2001/03/06 20:12:54  gerd
 * 	Dropping O'Caml 2 support
 *
 * Revision 1.1  2000/04/26 00:09:20  gerd
 * 	O'Caml 3 changes.
 *
 *
 * Orginal log from metascanner.ml:
 *
 * Revision 1.1  1999/06/20 19:26:26  gerd
 * 	Major change: Added support for META files. In META files, knowlege
 * about compilation options, and dependencies on other packages can be stored.
 * The "ocamlfind query" subcommand has been extended in order to have a
 * direct interface for that. "ocamlfind ocamlc/ocamlopt/ocamlmktop/ocamlcp"
 * subcommands have been added to simplify the invocation of the compiler.
 *
 *
 *)
